-배열의 초기값
배열은 자동으로 초기값을 가진다.
자료형에 따라 boolean은 false, String은 null, 정수는 0, 실수는 0.0등으로 초기화된다.

즉, 
int a;
라고 해놓고 초기화 하지 않은 상태로 a변수를 사용할 수는 없다.
다음과 같이 출력한다면 오류가 발생한다.
System.out.println(a);


그러나 배열의 경우는 
int []b = new b[5];
라고 하면 5개의 기억장소 모두 0으로 초기화되기에.
다음과 같이 출력문을 사용할 수 있다.
System.out.println(b[0]);// 0이 출력된다.

그러나 
배열을 선언하기만 하고 배열의 메모리 확보를 하기 전에는 사용할 수 없어요.

int []k;
라고만 하면 아직 배열이 확보되기 전이기 때문에 사용할 수 없다.

k[0] = 5;
라고 사용하면 오류가 발생합니다.
위에서 k를 정수형의 배열로 쓰겠습니다. 라고만 것이지
크기가 정해 지지 않았기 때문에 사용할 수 없다.

-다차원 배열

배열안에 또, 배열


일차원 배열
	int []a = new int[5]
	와 같은 경우를 일차원배열이라고 한다.

이차원 배열
	만약에 5개짜리 정수형 변수가 3묶음 필요하다면 다음과 같이 표현할 수 있다.
	int [][]a = new int[3][5];
	위의 경우를 2차원 배열이라고 하며
	2차원 배열이상을 "다차원배열"이라고 한다.

	"5칸짜리 정수형 변수가 3줄 있다"
	즉 정수형 변수가 15개가 만들어 진다.
	이것을 보통 행,열로 이야기 한다.
	3행, 5열의 이차원배열이라고 한다.
	
	위의 이차원 배열을 일괄처리 하려면 
	중첩반복문을 이용해야 한다.
	행을 위한 반복문안에서 열을 위한 반복문이 돌아야 한다.
	

삼차원 배열
	만약에 5칸짜리 정수형 변수가 3묶음 있고 그런것이 2장 필요하다면
	다음과 같이 표현할 수 있어요.

	int [][][]a = new int[2][3][5];

	위의 경우를 삼차원배열 이라고 합니다.

	2면,3행,5열으로 생각 하면 되겠습니다.
	
	이것을 일괄처리하기 위해서는 세개의 중첩 반복문을 이용해야 합니다.

	일반적으로 특별한 경우가 아니면 삼차원배열 이상은 잘 사용하지 않는다.


배열의 단점
	자료형이 같아야 한다.
	크기가 고정되어 있다.

	int []a = new int[5]
	라고 해 두면 
	int 밖에 담을 수 없고 
	5개 밖에 담을 수 없어요.

	사용자가 어떤 자료형을 담을지
	또, 몇개를 담을지 예측하기 
	어려운 경우에는 
	배열을 사용하기에는 불편합니다.

이러한 배열을 단점을 보완하기 위하여 
자바는 "향상된 배열"인
"컬렉션 프레임워크"를 제공합니다.

따라서 기본자료형의 배열보다는 
컬렉션 프레임워크를 사용하는것이 더 일반적입니다.


자바의 이차원배열에서는 
	각 행마다 열의 크기가 다를 수 있어요!

int [][]a = {{1,2},{3,4,5,6},{7,8,9}}; 

그러면, 이거 
일괄처리 어떻게 하나요?

for(int i=0; i<3; i++){
	for(int j=0; j < a[i].length  ; j++){

	}
}

자바에서는 각 행마다 
열의 크기가 다를 수 있으므로 
배열의 길이를 위한 속성을 사용합니다.

2차원 배열명인 a.length는 3입니다.
2차원 배열의 첫번째 요소인
a[0].length은 2입니다.
두번째 요소인 a[1].length는 4입니다.


-기본자료형 변수와  참조자료형 변수

기본자료형 변수는 변수자신이 값을 가지지만
참조자료형 변수는 변수자신이 값을 갖고 있는 것이 아니라
값이 있는 메모리를 참조합니다.

int a = 10;

위의 문장에서 a는 기본자료형 변수이며
변수자신이 10이라는 값을 갖고 있어요.

그러나 다음의 배열에서는
int []b = {10,20,30,40,50}

배열이름 b는 변수자신이 값을 갖고 있는 것이 아니라 
값이 있는 메모리를 참조합니다.
이러한 배열을 참조자료형이라고 합니다


-메소드
어떠한 문제해결을 위한(기능을 위한) 서로 관련있는 명령어들의 집합을 메소드라고 합니다.
어떤 일을 수행하기 위한 명령어들이 빈번하게 사용이 된다면 그 일을 처리하기 위한 
명령어들을 모아서 메소드로 만들어 두면 매번 똑같은 명령어들을 일일이 쓰지 않고 
메소드를 호출하여 사용할 수 있어요.

메소드를 만들때에는 다음과 같이 그 메소드가 수행하는 일에 알맞도록 이름을 정해주고 
소괄호를 반드시 열고 닫고 해야 합니다.
또, 소괄호 안에서는 그 메소드를 실행에 필요한 값을 전달받을 수도 있어요.
그 메소드의 역할에 따라 값을 전달받지 않을 수도 있고, 한개 전달 받을 수도 있고 
때에따라 여러개 전달 받을 수 있어요.

실제로 메소드가 해야하는 명령어 들은 
중괄호 {}속에다가 써 줍니다.

메소드이름( [자료형 변수명1, 자료형 변수명2, ... ]  ){
	메소드가 해야할 명령어(들)
}

이렇게 메소드를 만들어 놓고 
필요할 때에 메소드 이름을 써주면
메소드의 중괄호{}안의 명령어들이 차례로 
동작하고 다 동작이 끝나면
메소드를 호출한 쪽으로 되돌아갑니다.

때로는 메소드{} 중간에서 
다 끝나기도 전에 
어떠한 상황에 따라
중간에 나머지 명령어들을 마저 동작하지 않고 
되돌아 가게 할 수 도 있어요.
그때 되돌아 가게 하기 위한 명령어는 return입니다.

메소드 {} 의 맨끝에는 
return이라는 말을 쓰지 않아도 생략이 된 것입니다.

메소드를 만들때에 
메소드이름 왼쪽에 메소드의 자료형을 써 주어야 합니다.
메소드의 자료형이란
메소드는 호출문에 의해서 동작하고 
메소드의 내용이 다 끝나면 
메소드를 호출한 쪽으로 되돌아 갑니다.
이때 되돌아 갈때에 메소드 안에서 처리된 어떠한 결과값을 
갖고 되돌아 갈 수도 있고 아무값도 갖지 않고 빈손으로 되돌아 갈 수 도 있어요.
만약, 되돌아 갈때에 아무값도 갖지 않고 가는 경우를 "리턴값이 없다"라고 하고 
어떠한 처리된 결과 값을 갖고 가는 경우라면 "리턴값이 있다"라고 합니다.
만약 리턴값이 있는 경우라면 메소드 이름 왼쪽에 리턴값의 자료형을 써줍니다.
리턴값이 없는 경우에는 void라고 써줍니다.

가령, 메소드 안의 내용이 다음과 같다면

void 메소드이름(){
	return;
}

의 경우에는 리턴값이 없으므로 메소드이름 왼쪽에 
void라고 써야 합니다.

메소드의 내용이 다음과 같다면

int 메소드이름(){
	int sum = 0;
	어쩌구저쩌구...

	return sum;
}

위의 경우는 리턴값이 있으므로 메소드이름 왼쪽의 
리턴값의 자료형인 int를 써주어야 합니다.

메소드를 만들기 위해서는 
그 메소드를 사용하는 클래스 안에서 
메소드를 만들 수도 있고 

별도의 메소드를 포함하는 클래스를 
만들어 사용할 수도 있습니다.

우리가 어떠한 클래스안에 
메소드를 만들어 놓고 
그 메소드를 사용하려면

마치, Scanner의 next메소드를 사용하거나
Random의 next를 사용하거나
Date의 getYear를 사용할 때 처럼
반드시 객체를 생성 해 놓고 그 객체를 통해서 
메소드를 사용할 수 있어요!

그런데, 만약
System.out.println() 처럼
객체 없이도 사용하게 하려면

메소드이름 왼쪽에 static을 붙이면 
객체를 생성하지 않고 클래스이름.메소드이름() 으로 
바로 사용할 수도 있어요!

---------------------------------------------------------

만약, 구구단을 출력할 일이 많다면 
다음과 같이 몇단을 출력할 것인지를 변수로 전달받아 
해당하는 구구단을 출력하는 메소드를 만들수 있어요.

MyUtil이라는 클래스를 만들고 
그 클래스안에 dan을 매개변수로 전달받아 
구구단을 출력하는 gugudan 메소들 만들어 봅시다.

class MyUtil{
	void gugudan( int dan  ){
		System.out.printf("*** %d단 ***\n",dan);
		for(int i=1; i<=9; i++){
			System.out.printf("%d*%d=%d\n",dan,i,dan*i);
		}
	}
}

class MethodTest01{
	public static void main(String []args){
		MyUtil mu = new MyUtil();
		mu.gugudan(  );

	}

}


** 하나의 파일에 
두개이상의 클래스를 만들때에는 
메인메소드를 포함하는 클래스이름으로 파일명을 저장합니다.




메소드의 내용이 다음과 같다면

int 메소드이름(){
	int sum = 0;
	어쩌구저쩌구...

	return sum;
}


메소드를 호출한 결과값이 int입니다.
이 결과값을 메소드 호출한 쪽에서 변수에 담아 
다른 일 처리에 사용할 수 있어요!


int 변수이름 = 메소드이름();
무슨무슨처리...


-배열을 매개변수로 갖는 메소드

메소드자료형 메소드이름(자료형 []배열이름){

}

예를 들어 
int []a = {1,2,3,4,5}

라는 배열이 있고 이것을 매개변수로 
받은 메소드을 만들어 보면

void pro(int []data){
	
}

이메소드를 호출하려면 
pro(a)

라고 메소드호출시에 배열이름을 전달하면 됩니다.

이때 호출하는 배열이름과 
메소드의 매개변수의 배열이름은 같아도 상관없고 달라도 상관없어요!