상속
현실의 부모 자식 관계처럼 클래스에도 부모 자식 간의 관계가 있다
어떠한 클래스를 만들려고 속성, 동작을 분석했더니 이미 있는 어떤 클래스의 속성과 동작을 대부분 갖고 있고 거기에 새로운 속성 몇 가지와 동작을
추가해야 하는 경우라면 이미 있는 클래스의 속성, 동작을 다시 만들 필요 없이 상속받아서 새로운 클래스를 만들 수 있다

이 때, 상속을 해준 클래스를 부모 클래스(상위클래스,조상클래스), 상속 받은 클래스를 자식클래스(하위클래스, 후손클래스)라고 한다

자식클래스를 만들 때 부모클래스를 상속받고자 한다면 다음과 같이 extend 키워드를 사용한다

class A
{

}

class B extends A
{

}

이와 같이 되어 있을 때 A는 부모클래스 B는 자식클래스라고 한다
자동으로 B는 A의 모든 속성과 동작을 갖게 된다
따라서 B클래스 안에서는 A의 속성, 동작을 다시 쓸 필요가 없으며
새로 추가되는 속성, 동작을 만들면 된다

B의 객체를 생성하면 A의 모든 속성, 동작도 포함되므로 사용할 수 있다

그러나 아무리 상속받은 자식 클래스라 할지라도 부모클래스의 private영역에는 접근할 수 없다
그래서 어떠한 클래스를 만들 때에는 외부의 다른 클래스로부터는 보호하되
상속받은 자식클래스에게 접근을 허용할 속성들은 protected에 둔다

상속의 좋은 점은
이미 만들어둔 클래스를 다시 만들 필요 없이
확장하여 새로운 클래스를 만들 수 있다는 것
==> 이를 코드의 재사용을 높인다고 한다

상속과 생성자
어떤 클래스를 만들 때에 객체 생성시에 자동 수행되어 멤버변수들의 값을 초기화할 목적으로
생성자를 이용합니다

그럼 상속관계에 있을 때에 부모의 생성자가 먼저 동작하고 그 다음 자식의 생성자가 동작합니다

class A
{
   public A(){
   
   }

}

class B extends A{
        public B(){
	
	
	}



}

위와 같이 상속관계에 있을 때에 다음과 같이 B객체를 생성하면
B ob= new B();

A의 생성자가 먼저 동작하고 B의 생성자가 동작합니다

다음과 같이 생성자를 하나도 안 만들면 기본 생성자가 제공됩니다

생성자를 안 써도 기본 생성자가 제공되기 때문에
B의 객체를 생성할 수 있으며 자동으로 A의 매개변수를 갖지 않는 기본생성자가 먼저 동작하고
B의 매개변수를 갖지 않는 기본생성자가 차례로 동작합니다
B에는 수퍼가 생략되어있다 써도 되고 안 써도 된다
수퍼는 부모의 기본생성자를 호출한다
자식클래스 B의 생성자의 첫번째 줄에 부모클래스의 기본 생성자를 요구하는 super();
가 생략되어있다.
부모클래스 A클래스의 매개변수에 뭐가 있으면 기본생성자가 없어서 오류가 난다
이 문제를 해결하려면 부모클래스에 기본생성자를 만들어주거나
자식 클래스의 생성자에서 부모 클래스의 매개변수를 갖는 생성자를 요구해야 한다

만약 자식클래스에서 super로 매개변수가 들어있는 생성자를 요구하고 싶다면
부모 클래스가 public A(int i)로 int 형태라면 super안에 아무 정수형태로
super(100); 이렇게 쓴다

오버라이딩
부모 클래스로부터 물려받은 toString은 경작농원을 반환하지 않아
나한테 알맞도록 자식 클래스에서 다시 정의한다
그것을 메소드 오버라이딩

메소드 오버로딩 vs 메소드 오버라이딩

메소드 오버로딩은 상속과 상관 없다
==> 같은 이름의 메소드를 중복하여 정의하는 것
중복하여 정의하기 위해서는 메소드의 매개변수의 자료형,개수, 순서가 달라야한다

메소드 오버라이딩은 상속과 상관있다
==> 상속관계에 있을 때 부모클래스의 어떠한 메소드가 자식클래스에게 알맞지 않을 때에
자식 클래스에서 그것을 알맞도록 다시 정의(재정의)
이때에는 메소드 이름 뿐 아니라 반환자료형, 매개변수의 개수와 자료형까지 일치되게 재정의한다

