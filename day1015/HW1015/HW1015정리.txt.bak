상속관계에 있을 때 부모클래스의 참조변수가 자식클래스형의 객체를 참조할 수 있다
이때 부모클래스의 메소드를 자식클래스에서 오버라이딩했다면
오버라이딩한 메소드가 동작한다

그러나 부모클래스에는 없고 자식클래스에서 새로 추가한 메소드는 바로 호출할 수 없고
자식클래스로 형변환한다음에 사용할 수 있다
ex) ((SalariedEmployee)e1).setGrade(grade); //형변환의 예시
    ((HourlyEmployee)e1).setBase(base);


추상클래스와 추상메소드
어떤 클래스를 만들 때에 어떠한 메소드를 구체화할 수 없고
자식클래스들이 자신에게 알맞도록 재정의 해야만 할 메소드 인 경우
메소드의 body를 만들지 않고 메소드 이름만 써준다
이렇게 메소드의 body가 없는 메소드를 추상메소드라고 한다

이때 추상메소드임을 표시하기 위해서 메소드 이름 왼쪽에 abstract키워드를 붙인다
또 어떤 클래스가 추상 메소드를 하나라도 포함하고 있다면
그러한 클래스를 추상클래스라고 한다
추상클래스임을 표시하기 위해서 클래스 이름 왼쪽에 abstract키워드를 붙인다

일반적으로 클래스를 상속했을 때에 부모의 메소드를 오버라이딩할지 말지는
선택사항이다
그러나 부모클래스에서 추상메소드를 만들어두면 
반드시 자식클래스에서는 오버라이딩을 해줘야한다

다형성
객체에서 시킨 일은 동일한데
객체마다 하는 일이 다르다
객체에게 동일한 메소드를 호출하였는데
객체마다 하는 일이 다르다
객체에게 동일한 메세지를 주었는데
객체마다 하는 일이 다르다
여기서 메소들 호출=메세지를 주었다이다

상속관계에 있을 때에 부모의 메소드가 자식에게 알맞지 않을 경우
자식클래스에  맞도록 오버라이딩할 수 있다
이때 부모클래스의 객체와 자식 클래스의 객체가 동일한 메소드를 받았을 때에
객체마다 하는 일이 다르다
이것을 다형성이라고 한다

비행기와 새 둘다 날지만
비행기는 슝슝 날고
새는 훨훨 나는 것처럼

객체지향 프로그래밍의 특징
1. 은닉성: 외부로부터 클래스의 속성들을 노출하지 않고 보호하는 것
2. 상속성: 
3. 다형성: 

setter,getter,생성자 만드는 게 너무 귀찮습니다
어짜피 해야하는 코딩이 많습니다
누가 알아서 해줬음 좋겠는데요
그런 도구가 있습니다
이클립스, 인텔리제이 등이 있습니다
우리는 이클립스를 이용하겠습니다

이클립스에서는 클래스를 작성하고 저장하면 자동으로 컴파일을 해줍니다
(.class를 자동으로 만들어줍니다)
단, 코드에 문제가 있으면 컴파일을 못합니다
문제가 있는 코드는 이클립스가 표시를 해주니 걱정할 필요는 없습니다

여태까지는 하나의 파일에 여러가지 클래스를 만들었지만
이클립스에서는 파일하나에 하나의 클래스를 만드는 것이 일반적입니다

또, 클래스를 만들기 전에 서로 관련있는 클래스끼리 모아두기 위한 패키지를 먼저 만들고 
그 패키지에 클래스들을 만듭니다

패키지 이름은 보통 3개 이상의 스텝으로 만듭니다
com.sist.board

a.b.c
a 기관의 종류
b 기관명
c 서비스명

이클립스는 코딩의 생산속도를 위한 도구로 많은 부분에 있어 자동완성을 해줍니다
앞에 몇 글자만 적고 ctrl+space를 누르면 많은 부분을 자동완성해줍니다
System.out.println()
sout적고 ctrl+space

Student s= new Student()는
St 까지 적고 ctrl+space

Student하고 변수이름 정해주는 것도 귀찮습니다
그러면 Student까지만 적고
또, ctrl+space 누르면 student 변수명 어때?하고 추천해준다
맘에 들면 엔터치고
맘에 안들면 다른 변수명으로 바꾸면 된다

또, Student student= new 여기까지 쓰고
ctrl+space 누르면
Student클래스의 생성자 목록을 나열해준다
그 중에 원하는 것을 선택하여 엔터를 칠 수 있습니다

코드를 한줄 복사하려면
복사하려는 라인에 커서를 두고
ctrl+alt+방향키 아래를 누르면 한줄 복사가 된다

여러줄 복사하려면
복사하려는 부분을 마우스드래그로 선택한 후

자바의 클래스계층에서 최상위클래스는 object이다
자바가 제공하는 모든클래스의 제일조상클래스는 object입니다
우리가 만드는 클래스도 묵시적으로 object의 후손이 된다