this()?
this는 맴버변수와 매개변수의 이름이 같을 때 
멤버변수를 구별해주기 위해 쓰이는 변수이다
멤버변수 이름 앞에 this를 사용해서 구별
멤버변수와 매개변수 이름을 구분하여 프로그램의 가독성을 높임

this()는 같은 클래스 내의 다른 생성자 메서드를 호출할 때 사용 
this(어쩌구) 가 있으면 안의 어쩌구 매개변수 형태와 같은 생성자를 호출한다


this 키워드
클래스를 만들때에 
생성자나, 맴버메소드의 매개변수이름을 의미 있는 이름을 정해주다 보면
맴버변수이름과 동일하게 됩니다.
맴버변수의 이름과 매개변수의 이름이 동일할때에 
맴버메소드안에서 같은이름의 변수를 사용하게 되면 
매개변수이름이 우선순가 높아요.

class Person{
	private String name;
	private int age;

	public void setName(String name){
		name = name;		
		//이라고 하면 매개변수의 내용을 매개변수에 저장하라는 의미입니다.
		//따라서 맴버변수 name에 값이 저장되지 않아요
	}
}


이럴때에 
즉, 클래스를 만들때에 
맴버메소드의 매개변수 이름을 의미있는 이름으로 정해주다 보면 
맴버변수의 이름과 동일할게 됩니다. 
메소드안에서 
맴버변수에 접근하기 위해서는
this.맴버변수명으로 접근할 수 있어요

class Person{
	private String name;
	private int age;

	public void setName(String name){
		this.name = n;	
		//메소드안에서 맴버변수에 접근하기 위해서는 this키워드를 사용합니다.
		
	}
}


<< 생성자 >>

클래스이름과 같은 이름의 특수한 메소드를 말하며
이것은 다른 일반메소드처럼 호출문에 의해서 동작하는 것이 아니라
객체생성시에 자동수행되어 객체 생성함과 동시에 
맴버변수들의 값을 초기화 할 목적으로 사용합니다.

생성자는 일반 맴버메소드처럼 호출문에 의해서 동작하는 것이 아니라
객체생성시에 자동수행됩니다.
일반 맴버메소드는 호출문에 의해서 동작하고 메소드의 내용이 끝나면
자신을 호출한 곳으로 return하게 되어 있어요!
따라서 일반 맴버메소드이름의 왼쪽에서는 반드시 return type을 써줘야 해요.
return 값이 없을때에는 void라고 써줍니다.
void라고 하는 것은 메소드가 끝나면 return하는데 return값이 없다는 겁니다.

그러나, 생성자는 일반 맴버메소드 처럼 호출문에 의해서 동작하는 것이 아닙니다.
따라서 return의 개념이 없어요!
그래서 생성자 이름 왼쪽에서 return type을 쓰지 않아요!
void라고 쓰면 안됩니다!

생성자가 있으면 
setter는 필요없는가?
	==> 때에 따라 달라요
	==> 생성시에 정해진 맴버값을 실행중에 
			다른값으로 변경할 필요가 있다면 setter를 만듭니다.
	==> 보통, 생성자도 만들로 setter들도 만들어요!



class Person{
	private String name;
	private int age;
		
	public Person(){
		name = "김유신";
		age = 20;
	}

	public void setName(String name){
		this.name = name;
	}
	public void setAge(int age){
		this.age = age;
	}
}

Person kim = new Person();


<< 생성자의 매개변수 >>
생성자도 일반 메소드처럼 필요하다면 
매개변수를 가질 수도 있어요!

** setter, getter 만들기가 엄청 귀찮아요.
	앞으로 우리가 공부하게될 이클립스 도구에서는 
	자동으로 만들어 줍니다.
	또, 자동으로 만드는 것도 귀찮아요.
	그래서 있다고 치자는 Lombok이라는 것도 있어요.
	아직은 처음공부하고 있는 중이니 만드세요!

생성자의 중복
클래스를 만들때에 
생성자를 여러개 중복하여 만들 수 있어요.
매개변수를 하나도 갖지않는 생성자와 
매개변수를 한개 갖는 생성자
또는 두개 갖는 생성자 등.
여러개 중복하여 정의 할 수 있어요!

단, 생성자를 중복하여 정의할 때에는
생성자의 매개변수의 개수나 자료형이 달라야 합니다!

생성자의 매개변수의 이름으로 구분하지 않고
매개변수의 개수나 자료형으로 구분합니다!

class Emp{
	String name;
	int sal;
	String addr;

	public Emp(){							//A
		어쩌구저쩌구
	}

	public Emp(String name, int sal, String addr){		//B
		어쩌구저쩌구
	}
}

위와 같이 생성자를 중복하여 정의할 수 있어요!

Emp a = new Emp();
라고 하면 A의 생성자가 동작합니다.

Emp b = new Emp("홍길동", 500, "서울");
라고 하면 B의 생성자가 동작합니다.


-----------------------------------------------------------
class Emp{
	String name;
	int sal;
	String addr;

	public Emp(){							//A
		어쩌구저쩌구
	}

	public Emp(String name, int sal, String addr){		//B
		어쩌구저쩌구
	}

	public Emp(String name){					//C
		어쩌구저쩌구
	}

	public Emp(int sal){						//D
		어쩌구저쩌구
	}
}

위의 코드처럼
A,B,C,D 모두 생성자를 만들 수 있어요.
Emp a = new Emp();
Emp b = new Emp("홍길동", 500, "서울");
Emp c = new Emp("홍길동");
Emp d = new Emp(500);

객체 생성시에 전달되는 값의 자료형과 개수에 따른 
생성자가 자동으로 동작합니다.

위와같이 필요에 따라 생성자를 중복하여 정의 할 수 있어요!


-------------------------------------------------------
class Emp{
	String name;
	int sal;
	String addr;

	public Emp(String name){					//A
		어쩌구저쩌구
	}

	public Emp(String addr){					//B

	}
}

위와 같이 생성자를 중복하여 만들 수는 없어요!
생성자의 중복 조건은 매개변수의 이름이 아니라
매개변수의 개수나 자료형이 달라야 합니다. 
이미 String 매개변수 하나를 갖는 생성자가 있는데 
또, B와 같이 String의 매개 변수 하나를 갖는 생성자를 또, 만들 수는 없어요!

------------------------------------------------------------------------

<< 생성자의 중복 >>
생성자를 여러개 중복하여 정의하는 것을 말합니다. 
생성자를 중복하여 정의하기 위해서는 매개변수의 개수가 다르거나 자료형이 달라야 합니다.
